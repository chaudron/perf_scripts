# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-trace-python Documentation for the list of available functions.

#
# Run as: perf script -s ./analyze_perf_arp.py -i perf.data_arp_one
#
# See also: man perf-script-python
#

import os
import sys

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
	'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *


total_neigh_create = 0
total_arp_process = 0
total_write_lock_failed = 0
total_write_lock_failed_non_arp = 0
total_lock_sequences = 0

#
# Dictionary for global per CPU state:
#  0 => nonthing
#  1 => arp_create
#  2 => neight_create -> arp_create
#
cpu_state = {}
cpu_bridge = {}
cpu_sip = {}


def get_state(cpu):
    global cpu_state

    if cpu in cpu_state:
        return cpu_state[cpu]

    return 0


def set_state(cpu, state):
    global cpu_state
    cpu_state[cpu] = state


def trace_begin():
    print ">> START"


def trace_end():
        print "<< END"
        print("========== DONE ==========")
        print("neigh_create()      : {:-10}".format(total_neigh_create))
        print("arp_process()       : {:-10}".format(total_arp_process))
        print("write_lock_failed() : {:-10} [non arp = {}]".
              format(total_write_lock_failed, total_write_lock_failed_non_arp))
        print("total_lock_sequences: {:-10}".format(total_lock_sequences))


def probe__arp_process(event_name, context, common_cpu,
                       common_secs, common_nsecs, common_pid, common_comm,
                       common_callchain, __probe_ip, sip, name):

    global total_arp_process

    total_arp_process += 1

    # This will (re)set the state to 1
    set_state(common_cpu, 1)
    cpu_bridge[common_cpu] = name
    cpu_sip[common_cpu] = sip


def probe__neigh_create(event_name, context, common_cpu,
                        common_secs, common_nsecs, common_pid, common_comm,
                        common_callchain, __probe_ip, name):

    global total_neigh_create

    total_neigh_create += 1

    if get_state(common_cpu) == 1:
        set_state(common_cpu, 2)
    else:
        set_state(common_cpu, 0)


def probe__write_lock_failed(event_name, context, common_cpu,
                             common_secs, common_nsecs, common_pid,
                             common_comm, common_callchain, __probe_ip):

    global total_write_lock_failed
    global total_write_lock_failed_non_arp
    global total_lock_sequences

    total_write_lock_failed += 1

    for node in common_callchain:
        if 'sym' in node and node['sym']['name'] == '__neigh_create':
            if get_state(common_cpu) == 2:
                total_lock_sequences += 1
                ip = "{}.{}.{}.{}".format(
                    cpu_sip[common_cpu] & 0xff,
                    cpu_sip[common_cpu] >> 8 & 0xff,
                    cpu_sip[common_cpu] >> 16 & 0xff,
                    cpu_sip[common_cpu] >> 24 & 0xff)

                print("- write_lock_failed() on IP {:15s}"
                      " for bridge {}".format(ip,
                                              cpu_bridge[common_cpu]))

                set_state(common_cpu, 0)
                return

    total_write_lock_failed_non_arp += 1
    set_state(common_cpu, 0)


def trace_unhandled(event_name, context, event_fields_dict):
    print ' '.join(['%s=%s'%(k,str(v))for k,v in sorted(event_fields_dict.items())])


def print_header(event_name, cpu, secs, nsecs, pid, comm):
    print "%-20s %5u %05u.%09u %8u %-20s " % \
        (event_name, cpu, secs, nsecs, pid, comm),
